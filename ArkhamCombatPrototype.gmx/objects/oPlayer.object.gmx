<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sPlayerTemp</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>event_inherited();

accelAmt = 1;
decelAmt = 0.1;
movementSpdModifier = 300;

movingToTarget = false;

deadzone = 0.3;
turnSpd = 2;

HP = 1000;
maxHP = 2000;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/***************
*** MOVEMENT ***
****************/
normalizedSpdVector = clamp(point_distance(0,0,global.horizontalMov,global.verticalMov), 0.0, 1.00)

//deadzone
if (normalizedSpdVector &lt; deadzone) {
    normalizedSpdVector = 0.0;
} else {
    var stickDirection = point_direction(0,0,global.horizontalMov,global.verticalMov);
    var stickPlayerDiff = angle_difference(direction, stickDirection);
    
    if (abs(stickPlayerDiff) &gt; turnSpd) {
        if (stickPlayerDiff &lt; 0) {
            direction += turnSpd;
        } else if (stickPlayerDiff &gt; 0) {
            direction -= turnSpd;
        }
    } else {
        direction = stickDirection;
    }

    //direction = point_direction(0,0,global.horizontalMov,global.verticalMov);
}
normalizedSpdVector = ((normalizedSpdVector - deadzone) / (1 - deadzone))
normalizedSpdVector = clamp(normalizedSpdVector, 0, 1.00);
var maxInputSpd = normalizedSpdVector * movementSpdModifier * delta_time / 1000000;

if (maxInputSpd &gt; 0) {
    speed += accelAmt * (delta_time / 1000000);
    speed = clamp(speed, 0, maxInputSpd);
    //speed = maxInputSpd;
} else if (speed &gt; maxInputSpd) {
    speed -= decelAmt * (delta_time / 1000000);
    speed = clamp(speed, 0, maxInputSpd);
}

/*****************
*** TARGETTING ***
******************/

// Distance along the angle of the vision triangle, not distance to middle.
visionDistance = 500;
wideAngleFromCenter = 22;

wideVisionAngle_Left = direction + wideAngleFromCenter;
wideVisionAngle_Right = direction - wideAngleFromCenter;

leftVisionEndPoint_X = lengthdir_x(visionDistance, wideVisionAngle_Left)
leftVisionEndPoint_Y = lengthdir_y(visionDistance, wideVisionAngle_Left)
rightVisionEndPoint_X = lengthdir_x(visionDistance, wideVisionAngle_Right)
rightVisionEndPoint_Y = lengthdir_y(visionDistance, wideVisionAngle_Right)

enemiesInVision = getAryOfInstancesInTriangle(oEnemy, x, y, x + leftVisionEndPoint_X, y + leftVisionEndPoint_Y, x + rightVisionEndPoint_X, y + rightVisionEndPoint_Y)
enemyProximityRanking[0, 0] = -1;
enemyProximityRanking[0, 1] = -1;


if (enemiesInVision[0] &gt; 0) {
    for (var i = 0; i &lt; array_length_1d(enemiesInVision); i++) {
        var radianDiff = degtorad(abs(angle_difference(direction, point_direction(x, y,enemiesInVision[i].x, enemiesInVision[i].y))));
        var widthDist = sin(radianDiff) * distance_to_object(enemiesInVision[i]);
        var lengthDist = cos(radianDiff) * distance_to_object(enemiesInVision[i]);
        
        enemyProximityRanking[i, 0] = enemiesInVision[i];
        enemyProximityRanking[i, 1] = widthDist + lengthDist;
    }
}

// Sort enemyProximityRanking array by smallest number
if (enemyProximityRanking[0, 0] &gt; 0) {
    for (var i = 0; i &lt; array_height_2d(enemyProximityRanking); i++) {
        for (var o = i + 1; o &lt; array_height_2d(enemyProximityRanking); o++) {
            if (enemyProximityRanking[o, 1] &lt; enemyProximityRanking[i, 1]) {
                tempVar = enemyProximityRanking[i, 0];
                enemyProximityRanking[i, 0] = enemyProximityRanking[o, 0];
                enemyProximityRanking[o, 0] = tempVar;
                
                tempVar = enemyProximityRanking[i, 1];
                enemyProximityRanking[i, 1] = enemyProximityRanking[o, 1];
                enemyProximityRanking[o, 1] = tempVar;
            }
        }
    }
}

closestEnemy = enemyProximityRanking[0, 0]

/*************
*** ATTACK ***
**************/

if (global.Action3_Tap &amp;&amp; closestEnemy &gt; 0) {
    movingToTarget = true;
    lockedEnemy = closestEnemy;
}

if (movingToTarget) {
    direction = point_direction(x, y, lockedEnemy.x, lockedEnemy.y);
    speed = 2.5 * movementSpdModifier * delta_time / 1000000;
    
    if (place_meeting(x, y, lockedEnemy)) {
        movingToTarget = false;
        dmgChar(lockedEnemy, 100);
        stnChar(lockedEnemy, 0.5);
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw Player vision cone triangle
draw_set_color(c_white)

draw_set_alpha(0.2)
draw_triangle(x, y, x + leftVisionEndPoint_X, y + leftVisionEndPoint_Y, x + rightVisionEndPoint_X, y + rightVisionEndPoint_Y, false)

// Draw Player direction line
draw_set_alpha(1)

// Draw line to targetted enemy
if (instance_exists(closestEnemy)) {
    draw_line_width(x, y, closestEnemy.x, closestEnemy.y, 5);
}

// Health Bar
drawHealthBar(25, 10, 50, HP, maxHP);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
